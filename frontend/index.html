<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatRPG: Elodia</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <h1>ChatRPG: <span id="world-name">Loading...</span></h1>
            <div class="header-controls">
                <div id="status" class="status-indicator" title="Server Status"></div>
            </div>
        </header>

        <!-- MAIN GRID LAYOUT -->
        <div class="main-grid">

            <!-- TOP LEFT: VIEW (Map or Portrait) -->
            <div class="grid-cell top-left" id="view-panel">
                <!-- Exploration View: Map -->
                <div id="exploration-view-content" class="view-content">
                    <div id="map-container">
                        <div id="game-map">
                            <!-- Map tiles generated here -->
                        </div>
                    </div>
                </div>

                <!-- Interaction View: Portrait -->
                <div id="interaction-view-content" class="view-content hidden">
                    <div class="portrait-wrapper">
                        <img id="character-portrait" src="" alt="Portrait">
                        <div id="debug-inline-content-interaction"
                            style="display:none; margin-top:10px; font-family:monospace; font-size:0.8em; white-space:pre-wrap; color:#ccc;">
                        </div>
                        <div id="portrait-placeholder" class="portrait-placeholder">?</div>
                    </div>
                </div>
            </div>

            <!-- TOP RIGHT: STATS PANEL -->
            <div class="grid-cell top-right" id="context-panel">

                <!-- Time & Place (Always Visible) -->
                <div id="time-place-container"
                    style="padding: 15px; border-bottom: 1px solid #333; text-align: center;">
                    <div id="game-time" style="color: #888; font-size: 0.9em;">Day 1, Morning</div>
                    <div id="context-location" style="color: var(--accent-color); font-weight: bold; font-size: 1.1em;">
                        Unknown Location</div>
                </div>

                <!-- Accordion Container -->
                <div id="stats-accordion" class="scrollable-content" style="padding: 0; gap: 0;">

                    <!-- 1. Character Stats -->
                    <div class="accordion-item">
                        <button class="accordion-header" onclick="toggleAccordion('acc-stats')">Character Stats</button>
                        <div id="acc-stats" class="accordion-content open">
                            <div style="padding: 15px;">
                                <div id="player-stats-display"
                                    style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9em; color: #ccc;">
                                    <div>STR: <span id="stat-str" style="color:white">10</span></div>
                                    <div>DEX: <span id="stat-dex" style="color:white">10</span></div>
                                    <div>INT: <span id="stat-int" style="color:white">10</span></div>
                                    <div>CHA: <span id="stat-cha" style="color:white">10</span></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 2. Active Quests -->
                    <div class="accordion-item">
                        <button class="accordion-header" onclick="toggleAccordion('acc-quests')">Active Quests</button>
                        <div id="acc-quests" class="accordion-content">
                            <div id="active-quests-list" style="padding: 15px;">
                                <div style="color: #888; font-style: italic; font-size: 0.8em;">No active quests.</div>
                            </div>
                        </div>
                    </div>

                    <!-- 3. Local (Situation) -->
                    <div class="accordion-item">
                        <button class="accordion-header" onclick="toggleAccordion('acc-local')">Local</button>
                        <div id="acc-local" class="accordion-content open">
                            <div style="padding: 15px;">
                                <!-- Exploration Context -->
                                <div id="exploration-context">
                                    <div class="stat-card" style="border:none; background:none; padding:0;">
                                        <h3 style="margin-top:0;">Nearby</h3>
                                        <div id="local-list" style="display: flex; flex-direction: column; gap: 10px;">
                                            <div style="color: #888; font-style: italic;">No one nearby.</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Interaction Context -->
                                <div id="interaction-context" class="hidden">
                                    <div class="stat-card" style="border:none; background:none; padding:0;">
                                        <h3 style="margin-top:0;">Interaction</h3>
                                        <div id="npc-details">
                                            <h3 id="npc-name-display"
                                                style="color: var(--accent-color); margin:0; border:none;">Unknown</h3>
                                            <p id="npc-desc-display"
                                                style="font-size: 0.9rem; color: #ccc; margin-top: 5px;">...</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 4. Debug -->
                    <div class="accordion-item">
                        <button class="accordion-header" onclick="toggleAccordion('acc-debug')">Debug</button>
                        <div id="acc-debug" class="accordion-content">
                            <div style="padding: 15px;">
                                <div id="debug-panel-container">
                                    <button id="debug-btn" class="btn"
                                        style="width: 100%; opacity: 0.7; font-size: 0.8em; margin-bottom: 5px;"
                                        onclick="toggleDebugInline()">Refresh Debug Info</button>
                                    <button class="btn"
                                        style="width: 100%; opacity: 0.7; font-size: 0.8em; margin-bottom: 5px;"
                                        onclick="testQuestUI()">Test Quest UI</button>
                                    <button class="btn btn-danger"
                                        style="width: 100%; opacity: 0.7; font-size: 0.8em; margin-bottom: 5px;"
                                        onclick="clearDeadQuests()">Clear Dead Quests</button>
                                    <div id="debug-inline-content"
                                        style="display: none; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; font-family: monospace; font-size: 0.8em; color: #aaddff; white-space: pre-wrap; max-height: 200px; overflow-y: auto;">
                                        Select an NPC to view debug info.
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>

            <!-- BOTTOM LEFT: LOG (Chat/History) -->
            <div class="grid-cell bottom-left" id="log-panel">
                <div class="panel-header">Log</div>
                <div id="chat-container" class="log-container">
                    <div class="message system">Welcome to ChatRPG. Initializing...</div>
                </div>
                <div class="input-area">
                    <input type="text" id="main-input" placeholder="Type a command..." autocomplete="off">
                    <button class="btn" onclick="sendMainCommand()">Send</button>
                </div>
            </div>

            <!-- BOTTOM RIGHT: CONTROLS (Split: Nav | Actions) -->
            <div class="grid-cell bottom-right" id="controls-panel">
                <div class="panel-header">Controls</div>
                <div class="controls-content split-controls">
                    <!-- Left: Navigation (Hidden in Interaction) -->
                    <div id="nav-controls" class="control-half">
                        <div class="d-pad">
                            <button></button>
                            <button onclick="sendCommand('go north')">N</button>
                            <button></button>
                            <button onclick="sendCommand('go west')">W</button>
                            <button onclick="sendCommand('look')">üëÅÔ∏è</button>
                            <button onclick="sendCommand('go east')">E</button>
                            <button></button>
                            <button onclick="sendCommand('go south')">S</button>
                            <button></button>
                        </div>
                    </div>

                    <!-- Right: Actions -->
                    <div id="action-controls" class="control-half">
                        <!-- Exploration Actions -->
                        <div id="expl-actions">
                            <button class="btn" style="width: 100%; margin-bottom: 5px;"
                                onclick="sendCommand('inventory')">Inventory</button>
                            <button class="btn" style="width: 100%; background-color: #333; color: #fff;"
                                onclick="sendCommand('enter')">Enter</button>
                        </div>
                        <!-- Interaction Actions -->
                        <div id="int-actions" class="hidden">
                            <button class="btn btn-danger" style="width: 100%; margin-bottom: 10px;"
                                onclick="sendCommand('leave')">Leave</button>
                            <button class="btn" style="width: 100%; margin-bottom: 5px;"
                                onclick="sendCommand('trade')">Trade</button>
                        </div>
                    </div>
                </div>
            </div>

        </div>

    </div>

    <script>
        // --- State ---
        let sessionId = localStorage.getItem('chatrpg_session_id') || null;
        let currentGameMode = "EXPLORATION";
        let currentNpcId = null; // Track current NPC for debug

        // --- DOM Elements ---
        const chatContainer = document.getElementById('chat-container');
        const mainInput = document.getElementById('main-input');

        // --- Initialization ---
        window.onload = async () => {
            if (!sessionId) {
                const playerName = prompt("Enter your character name:", "Traveler") || "Traveler";
                const res = await fetchFromServer('/start', { player_name: playerName });
                if (res) updateState(res);
            } else {
                // Rejoin
                const res = await fetchFromServer('/start', { session_id: sessionId }); // Using /start to rejoin/refresh
                if (res) updateState(res);
            }

            // Input listeners
            mainInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMainCommand();
            });

            // Restore Accordion State
            restoreAccordionState();
        };

        // --- Accordion Logic ---
        function toggleAccordion(id) {
            const content = document.getElementById(id);
            const btn = content.previousElementSibling; // The button

            if (content.classList.contains('open')) {
                content.classList.remove('open');
                btn.classList.remove('active');
                localStorage.setItem('accordion_' + id, 'closed');
            } else {
                content.classList.add('open');
                btn.classList.add('active');
                localStorage.setItem('accordion_' + id, 'open');
            }
        }

        function restoreAccordionState() {
            const ids = ['acc-stats', 'acc-quests', 'acc-local', 'acc-debug'];
            ids.forEach(id => {
                const state = localStorage.getItem('accordion_' + id);
                const content = document.getElementById(id);
                const btn = content.previousElementSibling;

                if (state === 'closed') {
                    content.classList.remove('open');
                    btn.classList.remove('active');
                } else if (state === 'open') {
                    content.classList.add('open');
                    btn.classList.add('active');
                }
                // Default behavior is defined in HTML (open or not)
            });
        }

        // --- API ---
        async function fetchFromServer(endpoint, body) {
            try {
                const res = await fetch(`http://localhost:8000${endpoint}`, {
                    method: body ? 'POST' : 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    body: body ? JSON.stringify(body) : undefined
                });
                if (!res.ok) throw new Error(await res.text());
                return await res.json();
            } catch (err) {
                console.error(err);
                document.getElementById('status').className = 'status-indicator status-error';
                return null;
            }
        }

        // --- State Management ---
        async function updateState(data) {
            if (!data) return;

            // Update Session
            if (data.session_id) {
                sessionId = data.session_id;
                localStorage.setItem('chatrpg_session_id', sessionId);
            }

            // Update Game Mode
            const prevMode = currentGameMode;
            currentGameMode = data.game_mode || "EXPLORATION";
            console.log(`updateState: Mode changed from ${prevMode} to ${currentGameMode}`);

            // Update View Visibility
            updateViewVisibility(prevMode);

            // Update Common Stats (Removed from UI but data still available if needed)
            // const nameEls = ['player-name', 'player-name-int'];
            // const healthEls = ['player-health', 'player-health-int'];
            // const goldEls = ['player-gold', 'player-gold-int'];

            // nameEls.forEach(id => { if(document.getElementById(id)) document.getElementById(id).textContent = data.player_name; });
            // healthEls.forEach(id => { if(document.getElementById(id)) document.getElementById(id).textContent = data.health; });
            // goldEls.forEach(id => { if(document.getElementById(id)) document.getElementById(id).textContent = data.gold; });

            document.getElementById('world-name').textContent = data.world_name;
            if (document.getElementById('context-location')) document.getElementById('context-location').textContent = data.current_location;

            // Mode Specific Updates
            if (currentGameMode === "EXPLORATION") {
                updateExplorationState(data);
            } else {
                updateInteractionState(data);

                // Auto-Greeting Logic
                if (prevMode === "EXPLORATION" && !data.dialogue) {
                    sendInteractionCommand("Hello");
                }
            }

            // Update NPCs in location for Debug Context
            if (data.npcs_in_location) {
                window.lastNpcsInLocation = data.npcs_in_location;
            }

            // Update Player Stats
            if (data.player_stats) {
                document.getElementById('stat-str').textContent = data.player_stats.strength;
                document.getElementById('stat-dex').textContent = data.player_stats.dexterity;
                document.getElementById('stat-int').textContent = data.player_stats.intelligence;
                document.getElementById('stat-cha').textContent = data.player_stats.charisma;
            }

            // Update Active Quests
            updateActiveQuests(data.active_quests);

            refreshDebugInfo();
            document.getElementById('status').className = 'status-indicator status-ok';
        }

        function updateActiveQuests(quests) {
            const list = document.getElementById('active-quests-list');
            list.innerHTML = '';

            if (!quests || quests.length === 0) {
                list.innerHTML = '<div style="color: #888; font-style: italic; font-size: 0.8em;">No active quests.</div>';
                return;
            }

            // Filter for relevant quests (active, completed, failed)
            const visibleQuests = quests.filter(q => ['active', 'completed', 'failed'].includes(q.status));

            if (visibleQuests.length === 0) {
                list.innerHTML = '<div style="color: #888; font-style: italic; font-size: 0.8em;">No active quests.</div>';
                return;
            }

            visibleQuests.forEach(quest => {
                const item = document.createElement('div');
                item.style.marginBottom = '10px';
                item.style.padding = '5px';
                item.style.background = 'rgba(255,255,255,0.05)';

                // Status Styling
                let statusMsg = "";
                if (quest.status === 'completed') {
                    item.style.borderLeft = '4px solid #4caf50'; // Green
                    statusMsg = '<div style="color:#4caf50; font-weight:bold; font-size:0.8em; margin-bottom:3px;">‚úì Ready to Turn In</div>';
                } else if (quest.status === 'failed') {
                    item.style.borderLeft = '4px solid #f44336'; // Red
                    statusMsg = '<div style="color:#f44336; font-weight:bold; font-size:0.8em; margin-bottom:3px;">‚úï Quest Failed - Return to NPC</div>';
                } else {
                    item.style.borderLeft = '2px solid var(--accent-color)'; // Default Blue/Accent
                }

                let challengesHtml = '';
                if (quest.challenges) {
                    quest.challenges.forEach(ch => {
                        // Parse result if available
                        let result = null;
                        if (ch.result) {
                            try { result = JSON.parse(ch.result); } catch (e) { }
                        }

                        const isSuccess = result ? result.success : ch.completed; // Fallback
                        const statusColor = ch.completed ? (isSuccess ? '#4caf50' : '#f44336') : '#ff9800';
                        const statusIcon = ch.completed ? (isSuccess ? '‚úì' : '‚úï') : '‚óã';

                        // Roll Button / Auto-Resolution
                        let rollBtn = '';
                        if (!ch.completed && quest.status === 'active') {
                            if (ch.auto_result === 'auto_success') {
                                // Auto-Success: Show Claim Button
                                rollBtn = `<button class="btn" style="font-size:0.7em; padding:2px 5px; margin-left:5px; background-color: #4caf50; border-color: #4caf50;" onclick="rollChallenge('${quest.id}', '${ch.id}', '${ch.type}', ${ch.dc})">‚úì Auto-Complete</button>
                                           <div style="font-size: 0.8em; color: #aaddff; font-style: italic; margin-top: 2px;">${ch.auto_narrative || "Trivial task."}</div>`;
                            } else if (ch.auto_result === 'auto_failure') {
                                // Auto-Failure: Show Impossible Label
                                rollBtn = `<span style="font-size:0.7em; padding:2px 5px; margin-left:5px; color: #f44336; border: 1px solid #f44336; border-radius: 3px;">Impossible</span>
                                           <div style="font-size: 0.8em; color: #f44336; font-style: italic; margin-top: 2px;">${ch.auto_narrative || "Beyond your ability."}</div>`;
                            } else {
                                // Normal Roll
                                if (currentGameMode === "EXPLORATION") {
                                    rollBtn = `<button class="btn" style="font-size:0.7em; padding:2px 5px; margin-left:5px;" onclick="rollChallenge('${quest.id}', '${ch.id}', '${ch.type}', ${ch.dc})">Roll</button>`;
                                } else {
                                    rollBtn = `<button class="btn" style="font-size:0.7em; padding:2px 5px; margin-left:5px; opacity: 0.5; cursor: not-allowed;" title="Cannot roll during conversation" disabled>Roll</button>`;
                                }
                            }
                        }

                        challengesHtml += `
                            <div style="font-size: 0.85em; margin-top: 3px; display:flex; align-items:center; justify-content:space-between;">
                                <span><span style="color:${statusColor}">${statusIcon}</span> ${ch.description} (DC ${ch.dc} ${ch.type})</span>
                                ${rollBtn}
                            </div>
                        `;
                    });
                }

                item.innerHTML = `
                    ${statusMsg}
                    <div style="font-weight:bold; font-size:0.9em;">${quest.description}</div>
                    <div style="font-size:0.8em; color:#aaa;">Giver: ${quest.giver_npc}</div>
                    <div style="margin-top:5px; padding-left:10px;">
                        ${challengesHtml}
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function handleQuestOffer(quest) {
            console.log("Handling Quest Offer:", quest);
            const questDiv = document.createElement('div');
            questDiv.className = 'message system';
            questDiv.style.border = '1px solid var(--accent-color)';
            questDiv.style.padding = '10px';
            questDiv.style.marginTop = '10px';

            questDiv.innerHTML = `
                                <div style="font-weight:bold; color:var(--accent-color); margin-bottom:5px;">Quest Offered: ${quest.description}</div>
                <div style="font-size:0.9em; margin-bottom:10px;">
                    <div><strong>Giver:</strong> ${quest.giver_npc}</div>
                    <div><strong>Challenge:</strong> ${quest.challenges[0].description} (DC ${quest.challenges[0].dc} ${quest.challenges[0].type})</div>
                </div>
                <div style="display:flex; gap:10px;">
                    <button class="btn" onclick="acceptQuest('${quest.id}', this)">Accept</button>
                    <button class="btn btn-danger" onclick="refuseQuest('${quest.id}', this)">Refuse</button>
                </div>
                            `;

            document.getElementById('chat-container').appendChild(questDiv);
            scrollToBottom();
        }



        async function acceptQuest(questId, btn) {
            console.log("acceptQuest called for:", questId);
            const container = btn.parentElement;
            const buttons = container.querySelectorAll('button');
            buttons.forEach(b => b.disabled = true);

            try {
                console.log("Sending /accept_quest request...");
                const response = await fetchFromServer('/accept_quest', {
                    session_id: sessionId,
                    quest_id: questId
                });
                console.log("Response from /accept_quest:", response);

                if (response && response.status === 'success') {
                    console.log("Quest acceptance successful. Updating UI.");
                    container.innerHTML = '<span style="color:#4caf50; font-weight:bold;">Quest Accepted</span>';
                    // Refresh state to show in active quests
                    fetchGameState();

                    // Display pre-generated response
                    if (response.npc_response) {
                        addMessage(response.npc_response, 'model', document.getElementById('chat-container'));
                    }
                } else {
                    console.error("Quest acceptance failed or status not success:", response);
                    buttons.forEach(b => b.disabled = false);
                }
            } catch (error) {
                console.error('Error accepting quest:', error);
                buttons.forEach(b => b.disabled = false);
            }
        }

        async function refuseQuest(questId, btn) {
            console.log("refuseQuest called for:", questId);
            const container = btn.parentElement;
            const buttons = container.querySelectorAll('button');
            buttons.forEach(b => b.disabled = true);

            try {
                console.log("Sending /refuse_quest request...");
                const response = await fetchFromServer('/refuse_quest', {
                    session_id: sessionId,
                    quest_id: questId
                });
                console.log("Response from /refuse_quest:", response);

                if (response && response.status === 'success') {
                    console.log("Quest refusal successful. Updating UI.");
                    container.innerHTML = '<span style="color:#f44336; font-weight:bold;">Quest Refused</span>';

                    // Display pre-generated response
                    if (response.npc_response) {
                        addMessage(response.npc_response, 'model', document.getElementById('chat-container'));
                    }
                } else {
                    console.error("Quest refusal failed or status not success:", response);
                    buttons.forEach(b => b.disabled = false);
                }
            } catch (error) {
                console.error('Error refusing quest:', error);
                buttons.forEach(b => b.disabled = false);
            }
        }

        async function sendSystemMessage(text) {
            // Display as user action (italics/system style)
            const chatContainer = document.getElementById('chat-container');
            addMessage(text, 'user', chatContainer);

            try {
                const data = await fetchFromServer('/interact', {
                    session_id: sessionId,
                    message: text
                });
                updateState(data);
            } catch (error) {
                console.error('Error sending system message:', error);
            }
        }
        async function rollChallenge(questId, challengeId, challengeType, challengeDc) {
            if (!confirm("Roll for this challenge?")) return;

            const res = await fetchFromServer('/resolve_challenge', { session_id: sessionId, challenge_id: challengeId });

            if (res) {
                // Show Result in Chat
                let msg = `<strong>Challenge Result:</strong> Rolled ${res.roll} + ${res.stat_bonus} = ${res.total} (DC ${res.dc}). `;
                msg += res.success ? "<span style='color:#4caf50; font-weight:bold;'>SUCCESS!</span>" : "<span style='color:#f44336; font-weight:bold;'>FAILURE.</span>";
                if (res.critical_success) msg += " <span style='color:gold; font-weight:bold;'>CRITICAL SUCCESS!</span>";
                if (res.critical_failure) msg += " <span style='color:darkred; font-weight:bold;'>CRITICAL FAILURE!</span>";

                addMessage(msg, 'system', chatContainer);

                // Refresh Game State to update quest log
                await fetchGameState();

                // Report back to LLM (handled silently by backend now)
                // We no longer send an interaction command here to avoid triggering an immediate response.
                console.log("Challenge resolved. Backend history updated.");
            }
        }

        function updateViewVisibility(prevMode) {
            console.log(`updateViewVisibility: Current Mode: ${currentGameMode}, Prev Mode: ${prevMode}`);
            const explContent = document.getElementById('exploration-view-content');
            const intContent = document.getElementById('interaction-view-content');
            const explContext = document.getElementById('exploration-context');
            const intContext = document.getElementById('interaction-context');

            const navControls = document.getElementById('nav-controls');
            const explActions = document.getElementById('expl-actions');
            const intActions = document.getElementById('int-actions');

            // Buttons to disable/enable
            const navButtons = navControls.querySelectorAll('button');
            const enterBtn = document.querySelector('#expl-actions button:last-child'); // Enter button

            if (currentGameMode === "EXPLORATION") {
                explContent.classList.remove('hidden');
                intContent.classList.add('hidden');
                explContext.classList.remove('hidden');
                intContext.classList.add('hidden');

                // Controls: Enable Nav
                navButtons.forEach(btn => {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                });

                // Enable Enter
                if (enterBtn) {
                    enterBtn.disabled = false;
                    enterBtn.style.opacity = '1';
                    enterBtn.style.cursor = 'pointer';
                }

                explActions.classList.remove('hidden');
                intActions.classList.add('hidden');

                mainInput.placeholder = "Type a command...";
            } else {
                explContent.classList.add('hidden');
                intContent.classList.remove('hidden');
                explContext.classList.add('hidden');
                intContext.classList.remove('hidden');

                // Controls: Disable Nav (don't hide)
                navButtons.forEach(btn => {
                    btn.disabled = true;
                    btn.style.opacity = '0.3';
                    btn.style.cursor = 'not-allowed';
                });

                // Disable Enter (if visible, but we are hiding explActions anyway... wait, user said "disable NEWS buttons instead of hiding")
                // User also said "Lock it" for Enter.
                // Currently explActions is hidden in Interaction. 
                // If we want to keep the structure, we should maybe NOT hide explActions but disable them?
                // "if the interface structure doesn't change whether we're in conversation or navigation"
                // Let's keep explActions visible but swap the buttons? Or just disable Enter?
                // The user said "disable the NEWS buttons instead of hiding them".
                // For Enter, "Better if we just locked it".
                // But we have "Leave" and "Trade" in Interaction.
                // So we swap the Action buttons (Expl vs Int) but keep Nav buttons visible (disabled).

                explActions.classList.add('hidden'); // We swap these for Leave/Trade
                intActions.classList.remove('hidden');

                mainInput.placeholder = "Say something...";
            }
        }

        function updateExplorationState(data) {
            // Map
            renderMap(data.map_display);

            // Local List
            const localList = document.getElementById('local-list');
            localList.innerHTML = '';
            if (data.npcs_in_location && data.npcs_in_location.length > 0) {
                data.npcs_in_location.forEach(npc => {
                    const card = document.createElement('div');
                    card.className = 'stat-card';
                    card.style.cursor = 'pointer';
                    card.style.transition = 'background 0.2s';

                    let locationText = "";
                    if (npc.distance === 0) {
                        locationText = "<span style='color:#4caf50'>Here</span>";
                    } else {
                        locationText = `<span style='color:#888'>${npc.distance} steps away</span>`;
                    }

                    card.innerHTML = `
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <h3 style="margin: 0; color: var(--accent-color); border:none;">${npc.name}</h3>
                            <small>${locationText}</small>
                        </div>
                        <p style="font-size: 0.85rem; color: #ccc; margin-top:5px;">${npc.short_description}</p>
                        <div style="margin-top: 10px;">
                            <button class="btn" style="font-size: 0.8rem; padding: 5px 10px; width:100%;" 
                                onclick="sendCommand('talk to ${npc.name}')">Talk</button>
                        </div>
                    `;
                    card.onmouseover = () => card.style.background = 'rgba(255, 255, 255, 0.1)';
                    card.onmouseout = () => card.style.background = 'rgba(255, 255, 255, 0.05)';
                    localList.appendChild(card);
                });
            } else {
                localList.innerHTML = '<div style="color: #888; font-style: italic;">No one nearby.</div>';
            }

            // Chat Log (System messages)
            if (data.dialogue) {
                addMessage(data.dialogue, 'system', chatContainer);
            }
        }

        function updateInteractionState(data) {
            // Portrait
            const portraitImg = document.getElementById('character-portrait');
            const placeholder = document.getElementById('portrait-placeholder');

            if (data.character_portrait && !data.character_portrait.endsWith('None.png')) {
                portraitImg.src = `http://localhost:8000${data.character_portrait}`;
                portraitImg.style.display = 'block';
                placeholder.style.display = 'none';
            } else {
                portraitImg.style.display = 'none';
                placeholder.style.display = 'flex';
            }

            // NPC Name in Context
            if (data.conversation_partner_name) {
                document.getElementById('npc-name-display').textContent = data.conversation_partner_name;
                // We could also update description if available, but name is most important.
                document.getElementById('npc-desc-display').textContent = "In conversation...";

                // Update current NPC ID for debug
                currentNpcId = data.conversation_partner_name;
            } else {
                document.getElementById('npc-name-display').textContent = "Unknown";
                currentNpcId = null;
            }

            // Dialogue
            if (data.dialogue) {
                addMessage(data.dialogue, 'model', chatContainer);
            }
        }

        function renderMap(mapData) {
            const mapEl = document.getElementById('game-map');
            mapEl.innerHTML = '';

            if (!mapData || !mapData.grid) {
                mapEl.textContent = "No Map Data";
                return;
            }

            mapData.grid.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'map-row';
                row.forEach(cell => {
                    const tile = document.createElement('div');
                    tile.className = 'map-tile';
                    tile.textContent = cell.char;

                    if (cell.has_player) tile.classList.add('tile-player');
                    else if (cell.has_npc) tile.classList.add('tile-npc');
                    else if (cell.char === '#') tile.classList.add('tile-wall');
                    else if (cell.char === '.') tile.classList.add('tile-floor');
                    else tile.classList.add('tile-feature');

                    rowDiv.appendChild(tile);
                });
                mapEl.appendChild(rowDiv);
            });
        }

        function addMessage(text, type, container) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;

            // Format text
            let formattedText = text.replace(/\n/g, '<br>');
            formattedText = formattedText.replace(/"([^"]*)"/g, '<span class="dialogue-quote">"$1"</span>');

            msgDiv.innerHTML = formattedText;
            container.appendChild(msgDiv);
            container.scrollTop = container.scrollHeight;
        }

        async function fetchGameState() {
            try {
                const data = await fetchFromServer('/state', { session_id: sessionId });
                if (data) {
                    updateState(data);
                }
            } catch (error) {
                console.error("Error fetching game state:", error);
            }
        }

        // --- Commands ---
        async function sendCommand(cmd) {
            if (!cmd) return;

            // Optimistic UI update
            addMessage(cmd, 'user', chatContainer);

            let endpoint = '/command';
            let payload = { session_id: sessionId, command: cmd };

            const res = await fetchFromServer(endpoint, payload);
            if (res) updateState(res);
        }

        async function sendMainCommand() {
            const cmd = mainInput.value.trim();
            if (!cmd) return;
            mainInput.value = '';

            if (currentGameMode === "INTERACTION") {
                sendInteractionCommand(cmd);
            } else {
                sendCommand(cmd);
            }
        }

        async function sendInteractionCommand(msg) {
            if (!msg) return;
            // Optimistic UI
            addMessage(msg, 'user', chatContainer);
            const res = await fetchFromServer('/interact', { session_id: sessionId, message: msg });
            console.log("Interaction Response:", res); // Debug log
            if (res) {
                updateState(res);
                if (res.metadata && res.metadata.quest_offered) {
                    console.log("Quest offer found in metadata, triggering handler.");
                    handleQuestOffer(res.metadata.quest_offered);
                } else {
                    console.log("No quest_offered in metadata.");
                }

                // Check for Skill Check
                if (res.skill_check) {
                    handleSkillCheck(res.skill_check);
                } else if (res.metadata && res.metadata.skill_check) {
                    handleSkillCheck(res.metadata.skill_check);
                }
            }
        }

        function handleSkillCheck(check) {
            const container = document.getElementById('chat-container');
            const checkDiv = document.createElement('div');
            checkDiv.style.background = 'rgba(100, 50, 255, 0.1)';
            checkDiv.style.border = '1px solid #88f';
            checkDiv.style.padding = '10px';
            checkDiv.style.margin = '10px 0';
            checkDiv.style.borderRadius = '5px';
            checkDiv.id = 'active-skill-check';

            // Escape strings for onclick
            const safeSuccess = check.success_response.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const safeFailure = check.failure_response.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const safeDesc = check.description.replace(/'/g, "\\'").replace(/"/g, '&quot;');

            checkDiv.innerHTML = `
                <div style="font-weight:bold; color:#aaf; margin-bottom:5px;">Skill Check: ${check.type.toUpperCase()}</div>
                <div style="margin-bottom:10px;">${check.description} (DC ${check.dc})</div>
                <button class="btn" onclick="performSkillCheck('${check.type}', ${check.dc}, '${safeSuccess}', '${safeFailure}', '${safeDesc}')">Roll</button>
             `;
            container.appendChild(checkDiv);
            container.scrollTop = container.scrollHeight;
        }

        async function performSkillCheck(type, dc, success_response, failure_response, description) {
            // Remove the prompt
            const prompt = document.getElementById('active-skill-check');
            if (prompt) prompt.remove();

            const res = await fetchFromServer('/resolve_skill_check', {
                session_id: sessionId,
                type: type,
                dc: dc,
                success_response: success_response,
                failure_response: failure_response,
                description: description
            });

            if (res) {
                // Display Result
                const color = res.success ? '#4caf50' : '#f44336';
                const icon = res.success ? '‚úì' : '‚úï';
                const resultMsg = `<div style='color:${color}; font-weight:bold; margin: 5px 0;'>
                    ${icon} Rolled ${res.roll} + ${res.stat_bonus} = ${res.total} (DC ${res.dc}) - ${res.success ? 'SUCCESS' : 'FAILURE'}
                </div>`;
                addMessage(resultMsg, 'system', document.getElementById('chat-container'));

                // Display NPC Response
                if (res.npc_response) {
                    addMessage(res.npc_response, 'model', document.getElementById('chat-container'));
                }
            }
        }

        // --- Debug Inline Logic ---
        // --- Debug Inline Logic ---
        async function toggleDebugInline() {
            const contentDiv = document.getElementById('debug-inline-content');
            if (contentDiv.style.display === 'none') {
                contentDiv.style.display = 'block';
                updateDebugPanel();
            } else {
                contentDiv.style.display = 'none';
            }
        }

        async function updateDebugPanel() {
            const contentDiv = document.getElementById('debug-inline-content');
            const contentDivInteraction = document.getElementById('debug-inline-content-interaction');

            // Update both debug panels if they are visible
            if (contentDiv.style.display === 'none' && contentDivInteraction.style.display === 'none') return;

            // Determine target NPC: current partner OR first nearby NPC OR last known
            let targetId = currentNpcId;

            // If no current partner, try to find one from the last update
            if (!targetId && window.lastNpcsInLocation && window.lastNpcsInLocation.length > 0) {
                targetId = window.lastNpcsInLocation[0].id || window.lastNpcsInLocation[0].name;
            }

            if (targetId) {
                if (contentDiv.style.display !== 'none') contentDiv.textContent = "Loading debug info for " + targetId + "...";
                if (contentDivInteraction.style.display !== 'none') contentDivInteraction.textContent = "Loading debug info for " + targetId + "...";
                try {
                    const res = await fetch(`http://localhost:8000/npc_debug/${sessionId}/${targetId}`);
                    if (res.ok) {
                        const data = await res.json();
                        const debugText = JSON.stringify(data, null, 2);
                        if (contentDiv.style.display !== 'none') contentDiv.textContent = debugText;
                        if (contentDivInteraction.style.display !== 'none') contentDivInteraction.textContent = debugText;
                    } else {
                        const errorText = "Error fetching debug info: " + res.status;
                        if (contentDiv.style.display !== 'none') contentDiv.textContent = errorText;
                        if (contentDivInteraction.style.display !== 'none') contentDivInteraction.textContent = errorText;
                    }
                } catch (e) {
                    const errorText = "Error: " + e.message;
                    if (contentDiv.style.display !== 'none') contentDiv.textContent = errorText;
                    if (contentDivInteraction.style.display !== 'none') contentDivInteraction.textContent = errorText;
                }
            } else {
                const noNpcText = "No NPC selected or nearby.";
                if (contentDiv.style.display !== 'none') contentDiv.textContent = noNpcText;
                if (contentDivInteraction.style.display !== 'none') contentDivInteraction.textContent = noNpcText;
            }
        }

        function testQuestUI() {
            const dummyQuest = {
                id: "test_quest",
                description: "This is a test quest to verify the UI.",
                giver_npc: "Debug System",
                challenges: [
                    {
                        id: "test_challenge",
                        type: "intelligence",
                        dc: 10,
                        description: "Verify that the quest offer UI renders correctly."
                    }
                ]
            };
            handleQuestOffer(dummyQuest);
        }

        async function clearDeadQuests() {
            if (!confirm("Clear all completed and failed quests from the log?")) return;
            try {
                const res = await fetchFromServer('/debug/clear_quests', { session_id: sessionId });
                if (res && res.status === 'success') {
                    alert(`Cleared ${res.cleared_count} dead quests.`);
                    await fetchGameState();
                }
            } catch (e) {
                console.error("Error clearing quests:", e);
            }
        }

        function refreshDebugInfo() {
            updateDebugPanel();
        }

        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

    </script>
</body>

</html>